# TulipIndicators.jl

Julia bindings for [Tulip Indicators](https://github.com/TulipCharts/tulipindicators).

Dispatches on basic array types only, but `Tables.jl` compatible wrappers will be considered for the future.

This package is a work in progress.

## Getting Started
Download and install the package from the REPL with `] add <this_repo_url>`.

## Overview
The only functions this package exports are: `ti`, `tc`, and `{ti, tc}_info`.

Use `ti` to compute an indicator based on a `Symbol` identifier, valid identifiers can be found [here](https://tulipindicators.org/list). Because of how the upstream C library is written, this function takes in a vector of vectors although a matrix wrapper function exists that will convert the input and output for you.

The indicator may require options (parameters) to be supplied. The meaning and valid number of options can be found at the [upstream Tulip Indicators website](https://tulipindicators.org/list) or by calling `ti_info` with the identifier.

By default `ti` will pad the output with `Missing` values for indicators that introduce a lag. Set `pad=false` if you want to disable padding or `padval=<Cfloat>` for another pad value. I decided on this default to maintain alignment with DateTime arrays.

The `tc` function provides an interface to Tulip Candles. This is not a priority for me, but the interface exists if you want to play with it. I couldn't find documentation on the candle patterns, but they are part of the upstream C library so I included this interface.

## Toy Example
```julia
julia> using TulipIndicators

julia> ti_info()
Dict{Symbol, Union{Int32, Int64, String}} with 3 entries:
  :version         => "0.9.2"
  :indicator_count => 104
  :build           => 1660687722

julia> ti_info(:atr)
Dict{Symbol, Union{String, Vector{String}}} with 5 entries:
  :type      => "indicator"
  :full_name => "Average True Range"
  :inputs    => ["high", "low", "close"]
  :outputs   => ["atr"]
  :options   => ["period"]

julia> n=10
julia> hlc = [cumsum(ones(n)), -cumsum(ones(n)), zeros(n)]
julia> ti(:atr, hlc, [3.])
1-element Vector{Vector{Union{Missing, Float64}}}:
 [missing, missing, 4.0, 5.333333333333333, 6.888888888888888, 8.592592592592592, 10.395061728395062, 12.263374485596708, 14.175582990397805, 16.11705532693187]

julia> ti(:atr, hcat(hlc...), [3.]) # Matrix works too; Matrix inputs return Matrix outputs
10×1 Matrix{Union{Missing, Float64}}:
   missing
   missing
  4.0
  5.333333333333333
  6.888888888888888
  8.592592592592592
 10.395061728395062
 12.263374485596708
 14.175582990397805
 16.11705532693187

julia> ti(:atr, hcat(hlc...), [3.]; pad=false) # No padding
8×1 Matrix{Float64}:
  4.0
  5.333333333333333
  6.888888888888888
  8.592592592592592
 10.395061728395062
 12.263374485596708
 14.175582990397805
 16.11705532693187
```

## Details
* `src/base.jl` was autogenerated by Clang.jl from TulipIndicators_jll packaged header files, this file contains all common types and constants.
* `TulipIndicators.jl` calls `libindicators` C functions via [`@ccall`](https://docs.julialang.org/en/v1/base/c/)
* When a symbol is passed to `ti`, `ti_find_indicator` is `@ccall`ed, the resulting struct contains function pointers which can be `@ccall`ed to initialize and compute the indicator. A similar process occurs for `tc`.
* This avoids a whole bunch of unnecessary function definitions because `@ccall`/`ccall` [cannot be efficiently `@eval`ed over](https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Non-constant-Function-Specifications).

## TODO
* Interface that allows `Real` subtyped inputs and/or options.
* Publish unit tests

